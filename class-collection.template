struct ClassCollection
{
    static bool GetClassEntry(const char* name, const ClassEntry*& out_entry)
    {
        for (const ClassEntry& entry : entries)
        {
            if (strcmp(entry.name, name) == 0)
            {
                out_entry = &entry;
                return true;
            }
        }
        return false;
    }

    static bool GetClassProperties(const ClassEntry& class_entry, const std::vector<Property>*& out_properties)
    {
        out_properties = &class_entry.properties;
        return true;
    }

    static bool GetProperty(const ClassEntry& class_entry, const char* property_name, const Property*& out_prop)
    {
        for (const Property& prop : class_entry.properties)
        {
            if (strcmp(prop.name, property_name) == 0)
            {
                out_prop = &prop;
                return true;
            }
        }
        return false;
    }

    static bool Read(void* out_value, void* object, const char* class_name, const char* property_name)
    {
        if (object == nullptr || out_value == nullptr || class_name == nullptr || property_name == nullptr)
        {
            return false;
        }
        for (const ClassEntry& class_entry : entries)
        {
            if (strcmp(class_entry.name, class_name) != 0)
            {
                continue;
            }
            for (const Property& prop : class_entry.properties)
            {
                if (strcmp(prop.name, property_name) == 0)
                {
                    return Read(out_value, object, prop);
                }
            }
        }
        return false;
    }

    static bool Read(void* out_value, void* object, const Property& prop)
    {
        if (object == nullptr || out_value == nullptr)
        {
            return false;
        }
        if (prop.type_enum == Type::String)
        {
            std::string& out = *reinterpret_cast<std::string*>(out_value);
            std::string& in = *reinterpret_cast<std::string*>((char*)object + prop.offset);
            out = in;
        }
        else
        {
            memcpy(out_value, (char*)object + prop.offset, prop.size);
        }
        return true;
    }

    static bool Write(void* value, void* object, const char* class_name, const char* property_name)
    {
        if (object == nullptr || value == nullptr || class_name == nullptr || property_name == nullptr)
        {
            return false;
        }
        for (const ClassEntry& class_entry : entries)
        {
            if (strcmp(class_entry.name, class_name) != 0)
            {
                continue;
            }
            for (const Property& prop : class_entry.properties)
            {
                if (strcmp(prop.name, property_name) == 0)
                {
                    return Write(value, object, prop);
                }
            }
        }
        return false;
    }

    static bool Write(void* value, void* object, const Property& prop)
    {
        if (object == nullptr || value == nullptr)
        {
            return false;
        }
        if (prop.type_enum == Type::String)
        {
            std::string& in = *reinterpret_cast<std::string*>(value);
            std::string& out = *reinterpret_cast<std::string*>((char*)object + prop.offset);
            out = in;
        }
        else
        {
            memcpy((char*)object + prop.offset, value, prop.size);
        }
        return true;
    }

private:
    static inline const std::vector<ClassEntry> entries = __class_collection_entries__;
};
